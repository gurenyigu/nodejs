###### * 阻塞模式下，一个线程只能处理一项任务。
######  * 阻塞模式下，多线程往往能提高系统吞吐量。因为一个线程阻塞时还有其他线程在工作。多线程可以让CPU资源不被阻塞中的线程浪费。

###### * 非阻塞模式下，这个线程所使用的CPU核心利用率永远是100%，I/O以事件方式通知。
######  * 非阻塞模式下，线程不会被I/O阻塞，永远在利用CPU。多线程带来的好处仅仅是在多核CPU的情况下利用更多的核。(Nodejs的单线程也能带来同样的好处)
  
# 阻塞与非阻塞
* 阻塞I/O的一个特点是调用后一定要等到系统内核层面完成所有事件操作后，调用结束。
  * 读取磁盘上的一段文件为例，系统内核在完成磁盘寻道，读取数据，复制数据到内存中之后，这才调用结束。期间，阻塞I/O造成CPU等待I/O，占用I/O时间。CPU的性能不能充分利用，为了提高性能，内核提供了非阻塞I/O。
* 非阻塞I/O会在调用后立即返回。
### CPU时间片
> 分时操作系统是把CPU的时间划分成长短基本相同的时间区间,即"时间片"，通过操作系统的管理，把这些时间片依次轮流地分配给各个用户使用.如果某个作业在时间片结束之前,整个任务还没有完成，那么该作业就被暂停下来,放弃CPU，等待下一轮循环再继续做.此时CPU又分配给另一个作业去使用。由于计算机的处理速度很快，只要时间片的间隔取得适当,那么一个用户作业从用完分配给它的一个时间片到获得下一个CPU时间片，中间有所"停顿"，但用户察觉不出来,好像整个系统全由它"独占"似的。

### 引：单线程，异步I/O，事件驱动
>  应用程序的请求过程分为两部分：CPU运算和I/O读写，CPU计算速度通常高于磁盘读写速度，这就导致CPU运算已经完成，但是不得不等待磁盘I/O任务完成之后在继续接下来的任务。
所以I/O才是应用程序的瓶颈所在！(在I/O密集型业务中，假设请求需要100ms来完成，其中99ms花在I/O上。)如果需要优化应用程序，让他能同时处理更多的请求，我们会采用多线程，同时开启上百甚至上千的线程提高我们的请求处理。
但是由于CPU核心在一个时刻只能执行一个事件，因此操作系统通过事件切片的方法，让线程可以较为均匀的使用CPU资源。但操作系统在内核切换线程的同时也要切换线程上下文，当线程数量过多时，时间会被消耗在切换线程上线文中。所以在高并发时，多线程结构还是无法做到强大的伸缩性。

* Nodejs的单线程并不是一般理论的单线程，只是开启了单个线程进行业务处理(CPU运算)，同时开启了其他线程专供处理I/O。当一个指令到达主线程，主线程发现I/O之后，直接将这个事件传递给I/O线程，不等I/O结束，只拿到一个返回值，就去处理下面的业务。
###### * 这就是 单线程、异步I/O。
* I/O操作完成之后呢，Nodejs的I/O处理完会有一个回调事件，这个事件会放在一个事件处理队列里头，在进程启动时node会创建一个类似于while(1)的循环，这个循环的轮寻每一次够会去查看是否有返回事件需要处理。有则处理，没有则下一次轮询。
* 这就是所谓的事件驱动。在nodejs中，事件主要来源于网络请求，文件I/O等，根据时间的不同对观察者进行了分类。有文件观察者，网络I/O观察者。事件驱动是一个典型的生产者/消费者模型。请求到达观察者前，事件循环从观察者进行消费。主线程就可以马不停蹄的只关注业务不再取进行I/O等待。

[引用](https://www.zhihu.com/question/19732473)
### 同步、异步、阻塞、非阻塞

* 阻塞I/O模型：默认情况下，所有套接子都是阻塞的。先理解这个流程，一个输入操作通常包括两个阶段：
  * 等待数据准备好
  * 从内核向进程复制数据
  
  ![zhihu](https://pic4.zhimg.com/8244d924a12eaf42d61b41718c559bff_b.jpg)
  * 这两个术语的定义：
    * 同步I/O操作：导致请求进程阻塞，直到I/O操作完成
    * 异步I/O操作：不导致请求进程阻塞
  * 阻塞与非阻塞：进程/线程要访问的数据是否就绪，进程/线程是否需要等待
  * 同步与异步  ：访问数据的方式，同步需要主动读写数据，在读写数据的过程中还是会阻塞;异步只需要I/O操作完成的通知，并不主动读写数据，由操作系统内核完成数据读写。
